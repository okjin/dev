[ 1번 문제] : 이진수 자리 비교.
1~512 사이 정수 2개를 주어집니다. 그 수를 2진수로 표현했을 때, 


두 수의 2진수를 나란히 펼쳤을 때 같은 값의 개수를 출력하시오.


예를 들어 

12는 1 1 0 0

6 는 1 1 0
이므로 같은 값은 2개가 같은 자리 입니다.

주의 : 12의 이진수 1100 앞에 0000001100 의 숫자들은 비교대상에 포함되지 않습니다.




[1번 풀이 ]

: 1) 수 2개를 이진 수로 표현하고, 각 자리 수를 비교 할 것입니다.

2) 남은 앞자리는 비교의미 없으므로 임의의 수로 채워 줍니다. 

(ex : 12는 5555551100 , 6은 5555555110 으로 표현하고, 각 배열 자리의 1과 0 인 수만 비교 합니다.)

: 이진수는 수의 1, 2, 4, 8, 16, 32, 64, 128, 256 의 몫을 표현하고 있습니다.

그래서 , 

A 수가 주어지면, 256 으로 나눠서 몫이 있다면 A[8]에 1 대입. A가 256보다 작고 몫이 없다면 5, A보다 크지만 몫이 없다면 0을 넣습니다. 그리고 A에 256을 뺍니다.

그리고 그 나머지를 이번에 같은 방법으로 

A-256 을 128로 나눠서 몫이 있다면 A[7]에 1대입. (A-256)이 128보다 작고 몫이 없다면 5, A보다 크지만 몫이 없다면 0을 넣습니다. 그리고 A에 128을 뺍니다.

....

이런식으로 A[] 배열에 넣으면 이진수가 완성 됩니다.

B 수도 같은 방법으로 수를 넣으면 이진수가 완성되고, 두 수의 자리수가 1, 0 으로 일치하는 자리 개수를 출력하면 됩니다.





[2번 문제] 길찾기 문제
격자 모양에 임의로 블럭들이 있습니다. 
1,1 에서 오른쪽 끝 n,n까지의 이동경로를 출력해라. 

- 빠르고, 최적 경로를 출력할 필요없고, 지나가는 행로 좌표를 출력하시오. 

- 샘플테스트 데이터에서 빈셀은 0, 블럭은 1 로 테스트 파일이 주어질 것이며, 

10개의 테스트데이터에서 1000 x 1000 도 샘플로 제공 됩니다.


예를 들어, 아래와 같이 주어졌을 경우

□ 은 0 , ■ 은 1로 표현. 


□□□□□
■■■■□
□■□□□
□□■□■
□■■■■
□□□□□ 

(아래와 같이 대각선 방향도 이동 가능합니다)




대각선 방향도 이동이 가능함.


[2번문제 풀이]

: 길 찾기 문제로 출구찾는 알고리듬을 물어보는 문제 입니다. 

길찾기의 가장 기본은 왼쪽손을 벽에 손을 데고 계속 길을 걸어가다 보면, 출구를 찾을 수 있습니다. 

그런데, 이 문제는 대각선 방향도 허용하니, 왼쪽벽에 손이 아니라, 진행방향의 왼쪽 앞 대각선에 손을 펼치고( 8방향)

걸어 가야 합니다.


다시 말씀드리면, 

진행방향을 정하고 진행방향의 왼쪽부터 앞 시계방향으로 블럭이 있는지 체크하고 없다면 이동해서,
벽타고 마지막 자리까지 이동하면 완료되는 문제. 




만약 현재 내가 서 있는 위치가 5가 되고 주변 셀들을 

숫자로 표현 하면, 아래와 같이 될 것입니다.
123
456
789 

이때 만약 제가 

이전에 5 > 2 방향으로 이동하고 있었고( 즉 위로 한칸 이동 한다면)
, 다음 이동 방향을 결정해야 할 때, 

길이 막혀있는지 여부(주변 셀값의 체크)를 진행방향의 바로 왼쪽인 1,2,3,6,9,8,7,4 순으로 블럭유무 확인하며, 빈공간이면 이동합니다.

만약, 


5 > 3방향으로 이동하였었다면, 2,3,6,9,8,7,4,1 방향에 블럭확인 후 이동합니다.

(주의 할 점은 주어진 셀들 외벽은 모두 막혔으니, 셀범위 밖은 벽으로 간주합니다.)

1칸 이동시마다, x, y 셀 좌표를 순차적으로 출력하면 됩니다.


이렇게 셀(1,1) 에서 임의로 아무 방향하나 값을 넣어주고, 체크로직을 돌리면 완료 됩니다.